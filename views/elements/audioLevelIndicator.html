{{define "audioLevelIndicator"}}
<!-- Microphone input level indicator with dropdown -->
<div class="relative w-10 h-10" 
    role="status"
    x-data="{ 
        levels: {},
        selectedSource: null,
        smoothedVolumes: {},
        smoothingFactor: 0.4,
        dropdownOpen: false,
        zeroLevelTime: {},
        eventSource: null,
        reconnectAttempts: 0,
        maxReconnectAttempts: 5,
        reconnectDelay: 1000,
        isNavigating: false,
        retryTimeout: null,
        audioContext: null,
        audioWorkletNode: null,
        webSocket: null,
        sseSource: null,
        streamTransport: '{{if .Settings.Realtime.Audio.StreamTransport}}{{.Settings.Realtime.Audio.StreamTransport}}{{else}}auto{{end}}', // Can be 'auto', 'sse', or 'ws'
        isPlaying: false,
        pcmDataQueue: [],
        audioBufferSize: 4096, // Changed back to 4096 (power of two) as required by ScriptProcessorNode
        incomingChunkSize: 3072, // The actual size of incoming audio chunks from the server
        sampleRate: 48000, // Default sample rate
        audioLatency: 300, // Reduced from 500 to better match real-time needs
        pingInterval: null,
        bufferThreshold: 3, // Decreased to start playback sooner with fewer packets
        processingStarted: false,
        jitterBufferSize: 3, // Reduced jitter buffer size to prevent excessive buffering
        bufferStatsInterval: null, // For buffer health monitoring
        bufferUnderrunCount: 0, // Count of buffer underruns for diagnostics
        sseStalled: false,
        sseStallRecoveryAttempts: 0,
        lastDataTime: null,
        _requestedPermission: false,

        isInactive(source) {
            // If we don't have the source in levels at all, consider it inactive
            if (!this.levels[source]) {
                return true;
            }
            // If the source has a non-zero level, it's active
            if (this.levels[source].level > 0) {
                return false;
            }
            // If we haven't started tracking zero time for this source yet
            if (!this.zeroLevelTime[source]) {
                this.zeroLevelTime[source] = Date.now();
                return false;
            }
            // Source is inactive if it has had zero level for more than 5 seconds
            return (Date.now() - this.zeroLevelTime[source]) > 5000;
        },

        cleanupEventSource() {
            if (this.eventSource) {
                this.eventSource.close();
                this.eventSource = null;
            }
            if (this.retryTimeout) {
                clearTimeout(this.retryTimeout);
                this.retryTimeout = null;
            }
        },

        setupEventSource() {
            // Don't setup if we're navigating away or already have a connection
            if (this.isNavigating || this.eventSource) {
                return;
            }
            
            this.cleanupEventSource();
            
            this.eventSource = new EventSource('/api/v1/audio-level');
            
            this.eventSource.onmessage = (event) => {
                // Skip processing if we're navigating away
                if (this.isNavigating) {
                    this.cleanupEventSource();
                    return;
                }
                
                try {
                    const data = JSON.parse(event.data);
                    if (data.type === 'audio-level') {
                        if (!data.levels) {
                            return;
                        }
                        
                        // Reset reconnect attempts on successful message
                        this.reconnectAttempts = 0;
                        this.reconnectDelay = 1000;
                        
                        // Update levels and track zero level times
                        const oldSources = Object.keys(this.levels);
                        this.levels = data.levels;
                        const newSources = Object.keys(this.levels);
                        
                        // Track when sources start having zero levels
                        Object.entries(this.levels).forEach(([source, data]) => {
                            if (data.level === 0) {
                                if (!this.zeroLevelTime[source]) {
                                    this.zeroLevelTime[source] = Date.now();
                                }
                            } else {
                                delete this.zeroLevelTime[source];
                            }
                        });
                        
                        // Initialize smoothedVolumes for new sources
                        Object.keys(this.levels).forEach(source => {
                            if (!(source in this.smoothedVolumes)) {
                                this.smoothedVolumes[source] = 0;
                            }
                        });
                        
                        // Set first source as selected if none selected
                        if (!this.selectedSource || !(this.selectedSource in this.levels)) {
                            const sources = Object.keys(this.levels);
                            if (sources.length > 0) {
                                this.selectedSource = sources[0];
                            }
                        }
                        
                        // Update smoothed volumes
                        Object.entries(this.levels).forEach(([source, data]) => {
                            const oldVolume = this.smoothedVolumes[source] || 0;
                            this.smoothedVolumes[source] = this.smoothingFactor * data.level + 
                                (1 - this.smoothingFactor) * oldVolume;
                        });
                    }
                } catch (error) {
                    console.error('Error processing SSE data:', error);
                }
            };
            
            this.eventSource.onerror = (error) => {
                console.error('EventSource error:', error);
                this.cleanupEventSource();
                
                // Don't attempt reconnection if we're navigating away
                if (this.isNavigating) {
                    return;
                }
                
                // Implement exponential backoff for reconnection
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.retryTimeout = setTimeout(() => {
                        this.reconnectAttempts++;
                        this.reconnectDelay = Math.min(this.reconnectDelay * 2, 10000); // Cap at 10 seconds
                        console.log(`Reconnecting to SSE (attempt ${this.reconnectAttempts})...`);
                        this.setupEventSource();
                    }, this.reconnectDelay);
                } else {
                    console.error('Max reconnection attempts reached');
                }
            };
        },

        initAudio() {
            // Reduce console logging - only log critical state changes
            console.log('Initializing audio system...');
            
            try {
                // Create new AudioContext if needed
                if (!this.audioContext) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.audioContext = new AudioContext({
                        latencyHint: 'interactive',
                        sampleRate: this.sampleRate
                    });
                    
                    // Request permission for background audio playback in Safari and mobile
                    if ('audioWorklet' in this.audioContext && !this._requestedPermission) {
                        this._requestedPermission = true;
                        
                        // For Safari and iOS - attempt to enable background audio
                        if (typeof document.webkitAudioPlaybackAllowed === 'boolean') {
                            // Attempt to get user gesture to enable audio background playback
                            this.audioContext.resume().then(() => {
                                console.log('Audio context resumed for background playback permission');
                            });
                        }
                    }
                    
                    // Keep this log as it's useful for troubleshooting
                    console.log(`Created AudioContext with sample rate ${this.audioContext.sampleRate}Hz`);
                }
                
                // Check for modern AudioWorklet support
                if (this.audioContext.audioWorklet) {
                    // Load audio processor
                    this.audioContext.audioWorklet.addModule('/assets/audio-processors/pcm-audio-processor.js')
                        .then(() => {
                            // Create audio worklet node
                            const workletNode = new AudioWorkletNode(this.audioContext, 'pcm-audio-processor');
                            
                            // Connect the worklet to the audio output
                            workletNode.connect(this.audioContext.destination);
                            
                            // Store the worklet node for later access
                            this.audioWorkletNode = workletNode;
                        })
                        .catch(error => {
                            // Keep error logs for troubleshooting
                            console.error('Error loading AudioWorklet:', error);
                            this.fallbackToScriptProcessor();
                        });
                } else {
                    this.fallbackToScriptProcessor();
                }
            } catch (error) {
                // Keep error logs for troubleshooting
                console.error('Error initializing audio system:', error);
                alert('Audio playback initialization failed. Please check console for details.');
            }
        },

        // Add fallback to ScriptProcessorNode for browsers that don't support AudioWorkletNode
        fallbackToScriptProcessor() {
            // Keep this log as it indicates a fallback state
            console.log('Falling back to ScriptProcessorNode for audio processing');
            
            try {
                const bufferSize = this.audioBufferSize;
                const scriptNode = this.audioContext.createScriptProcessor(bufferSize, 0, 1);
                
                scriptNode.onaudioprocess = (e) => {
                    const outputData = e.outputBuffer.getChannelData(0);
                    let outputPosition = 0;
                    
                    if (!this.processingStarted && this.pcmDataQueue.length >= this.bufferThreshold) {
                        // Keep this log as it indicates start of playback
                        console.log(`Starting audio playback with ${this.pcmDataQueue.length} packets in queue`);
                        this.processingStarted = true;
                    }
                    
                    if (this.processingStarted) {
                        // Process all data in the queue
                        while (this.pcmDataQueue.length > 0 && outputPosition < outputData.length) {
                            const currentChunk = this.pcmDataQueue[0];
                            
                            if (!currentChunk || currentChunk.length < 2) {
                                this.pcmDataQueue.shift();
                                continue;
                            }
                            
                            // Process 16-bit PCM data (convert to float)
                            let i;
                            for (i = 0; i < currentChunk.length - 1 && outputPosition < outputData.length; i += 2) {
                                const lo = currentChunk[i];
                                const hi = currentChunk[i + 1];
                                let sample = (hi << 8) | lo;
                                if (sample > 32767) sample -= 65536;
                                
                                outputData[outputPosition++] = sample / 32768.0;
                            }
                            
                            if (i >= currentChunk.length - 4) {
                                this.pcmDataQueue.shift();
                            } else {
                                this.pcmDataQueue[0] = currentChunk.slice(i);
                            }
                        }
                        
                        if (outputPosition < outputData.length) {
                            const fillPercentage = Math.round((outputPosition / outputData.length) * 100);
                            
                            for (let i = outputPosition; i < outputData.length; i++) {
                                outputData[i] = 0;
                            }
                            
                            // Only log severe underruns (less than 75% filled)
                            if (fillPercentage < 75) {
                                this.bufferUnderrunCount++;
                                console.warn(`Buffer underrun #${this.bufferUnderrunCount} - filled ${fillPercentage}%`);
                                
                                if (fillPercentage < 50) {
                                    console.warn('Significant buffer underrun - resetting processing');
                                    this.processingStarted = false;
                                }
                            }
                        }
                    } else {
                        for (let i = 0; i < outputData.length; i++) {
                            outputData[i] = 0;
                        }
                    }
                };
                
                scriptNode.connect(this.audioContext.destination);
                this.audioWorkletNode = scriptNode;
                
                // Keep this log as it indicates initialization success state
                console.log(`Audio system initialized with ScriptProcessorNode (buffer size: ${bufferSize})`);
            } catch (error) {
                // Keep error logs for troubleshooting
                console.error('Error initializing fallback audio system:', error);
            }
        },

        setupWebSocketForSource(sourceId) {
            this.closeExistingConnections();
            
            this.pcmDataQueue = [];
            this.processingStarted = false;
            this.bufferUnderrunCount = 0;
            
            this.bufferThreshold = Math.max(2, Math.ceil(this.audioBufferSize / this.incomingChunkSize));
            
            if (this.bufferStatsInterval) {
                clearInterval(this.bufferStatsInterval);
            }
            
            // Reduce buffer stats logging frequency to once every 30 seconds, and only if playing
            this.bufferStatsInterval = setInterval(() => {
                if (this.isPlaying && Math.random() < 0.1) { // Only log ~10% of the time
                    const samples = this.pcmDataQueue.reduce((acc, chunk) => acc + Math.floor(chunk.length / 2), 0);
                    const bufferTimeMs = (samples / this.sampleRate) * 1000;
                    console.log(`Buffer health: ${this.pcmDataQueue.length} packets, ~${samples} samples (${bufferTimeMs.toFixed(1)}ms), underruns: ${this.bufferUnderrunCount}`);
                }
            }, 30000); // Increased from 2000ms to 30000ms
            
            if (this.streamTransport === 'sse' || (this.streamTransport === 'auto' && this.isCloudflareOrDocker())) {
                this.setupSSEForSource(sourceId);
            } else {
                this.setupWebSocketConnection(sourceId);
            }
        },
        
        isCloudflareOrDocker() {
            // Check if we're likely behind Cloudflare or in a Docker container
            const hostName = window.location.hostname;
            const path = window.location.pathname;
            
            // Check for Cloudflare-specific headers or common Docker port mappings
            const isCloudflareLikely = 
                document.cookie.indexOf('__cfduid') !== -1 || 
                document.cookie.indexOf('cf_clearance') !== -1 ||
                hostName.indexOf('workers.dev') !== -1 ||
                hostName.indexOf('pages.dev') !== -1;
                
            // Check for common Docker port mappings or Traefik
            const isDockerLikely = 
                window.location.port && ['8080', '8000', '3000', '5000', '8888'].includes(window.location.port) ||
                path.indexOf('/proxy/') !== -1 ||
                document.cookie.indexOf('_traefik_') !== -1;
                
            return isCloudflareLikely || isDockerLikely;
        },
        
        closeExistingConnections() {
            // Clear stall detection interval
            if (this.sseStallCheckInterval) {
                clearInterval(this.sseStallCheckInterval);
                this.sseStallCheckInterval = null;
            }
            
            // Close any existing WebSocket connection
            if (this.webSocket) {
                this.webSocket.close();
                this.webSocket = null;
            }
            
            // Close any existing SSE connection
            if (this.sseSource) {
                this.sseSource.close();
                this.sseSource = null;
            }
        },
        
        setupSSEForSource(sourceId) {
            try {
                if (this.sseSource) {
                    return;
                }
                
                this.sseSource = new EventSource(`/api/v1/audio-stream/${sourceId}`);
                
                this.lastDataTime = Date.now();
                this.sseStalled = false;
                
                this.sseStallCheckInterval = setInterval(() => {
                    if (this.sseSource && this.isPlaying) {
                        const stalledTime = Date.now() - this.lastDataTime;
                        // Only log if connection appears stalled for a long time (5+ seconds)
                        if (stalledTime > 5000 && !document.hidden) {
                            console.warn(`SSE connection appears stalled (${stalledTime}ms without data)`);
                            this.sseStalled = true;
                            
                            if (this.sseStallRecoveryAttempts < 3) {
                                this.sseStallRecoveryAttempts++;
                                if (this.sseSource) {
                                    this.sseSource.close();
                                    this.sseSource = null;
                                }
                                setTimeout(() => {
                                    this.setupSSEForSource(sourceId);
                                }, 500);
                            }
                        }
                    }
                }, 2000);
                
                this.sseSource.onopen = () => {
                    // Keep connection established log but make it less verbose
                    console.log(`SSE connected to ${sourceId}`);
                    this.sseStalled = false;
                    this.sseStallRecoveryAttempts = 0;
                    this.lastDataTime = Date.now();
                    
                    // Always resume the audio context when SSE connects, regardless of visibility
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume().then(() => {
                        }).catch(err => {
                            console.error('Failed to resume audio context:', err);
                        });
                    }
                };
                
                this.sseSource.addEventListener('audio', (event) => {
                    this.lastDataTime = Date.now();
                    this.sseStalled = false;
                    
                    if (event.data) {
                        try {
                            const base64Data = event.data;
                            const binaryString = atob(base64Data);
                            const audioData = new Uint8Array(binaryString.length);
                            
                            for (let i = 0; i < binaryString.length; i++) {
                                audioData[i] = binaryString.charCodeAt(i);
                            }
                            
                            if (audioData.length < 32) {
                                console.warn(`Received unusually small audio chunk: ${audioData.length} bytes`);
                                return;
                            }
                            
                            // Drastically reduce audio data logs
                            const shouldLog = document.hidden ? Math.random() < 0.0001 : Math.random() < 0.001;
                                             
                            if (shouldLog) {
                                const samples = Math.floor(audioData.length / 2);
                                console.log(`Received audio data: ${audioData.length} bytes, queue: ${this.pcmDataQueue.length} packets`);
                            }
                            
                            // MODIFIED: Always process audio data regardless of visibility
                            if (this.audioWorkletNode && this.audioWorkletNode.port) {
                                if (this.audioContext && this.audioContext.state === 'running') {
                                    try {
                                        this.audioWorkletNode.port.postMessage({
                                            type: 'buffer',
                                            buffer: audioData
                                        });
                                    } catch (err) {
                                        console.error('Error sending data to AudioWorklet:', err);
                                        this.pcmDataQueue.push(audioData);
                                    }
                                } else {
                                    this.pcmDataQueue.push(audioData);
                                }
                            } else {
                                this.pcmDataQueue.push(audioData);
                                
                                // You can keep different buffer sizes based on visibility
                                const maxQueueSize = document.hidden ? 30 : 12; 
                                const minQueueSize = document.hidden ? 10 : 3;
                                
                                if (this.pcmDataQueue.length > maxQueueSize) {
                                    if (this.pcmDataQueue.length > maxQueueSize + 3) {
                                        const toRemove = Math.min(3, this.pcmDataQueue.length - maxQueueSize);
                                        this.pcmDataQueue.splice(1, toRemove);
                                        // Only log major overflow in visible state, and only rarely
                                        if (!document.hidden && Math.random() < 0.02) {
                                            console.warn(`Queue overflow: removed ${toRemove} packets`);
                                        }
                                    } else {
                                        const middleIndex = Math.floor(this.pcmDataQueue.length / 2);
                                        this.pcmDataQueue.splice(middleIndex, 1);
                                    }
                                }
                            }
                        } catch (error) {
                            console.error('Error processing SSE audio data:', error);
                        }
                    }
                });
                
                this.sseSource.addEventListener('connected', () => {
                    // Keep this log as it indicates successful connection
                    console.log('SSE audio stream connected');
                    this.lastDataTime = Date.now();
                });
                
                this.sseSource.onerror = (error) => {
                    // Keep error logs for troubleshooting
                    console.error('SSE connection error:', error);
                    
                    if (!this.isPlaying) {
                        this.sseSource.close();
                        this.sseSource = null;
                        return;
                    }
                };
                
            } catch (error) {
                console.error('Error setting up SSE connection:', error);
                
                // Fall back to WebSocket if SSE setup fails
                if (this.streamTransport === 'auto') {
                    console.log('Falling back to WebSocket connection');
                    this.setupWebSocketConnection(sourceId);
                }
            }
        },
        
        setupWebSocketConnection(sourceId) {
            // Create a new WebSocket connection
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${wsProtocol}//${window.location.host}/api/v1/audio-stream/${sourceId}?transport=ws`;
            
            try {
                this.webSocket = new WebSocket(wsUrl);
                
                this.webSocket.binaryType = 'arraybuffer';
                
                // Handle connection open
                this.webSocket.onopen = () => {
                    // Keep this connection log
                    console.log(`WebSocket connected to ${sourceId}`);
                    
                    // Resume the AudioContext regardless of visibility
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume().catch(err => {
                            console.error('Failed to resume audio context:', err);
                        });
                    }
                };
                
                // Handle incoming audio data with improved buffering
                this.webSocket.onmessage = (event) => {
                    if (event.data instanceof ArrayBuffer) {
                        // Convert ArrayBuffer to Uint8Array for processing
                        const audioData = new Uint8Array(event.data);
                        
                        // Skip empty or very small chunks
                        if (audioData.length < 32) {
                            console.warn(`Received unusually small audio chunk: ${audioData.length} bytes`);
                            return;
                        }
                        
                        // Drastically reduce logging - only about 1 in 1000 messages
                        if (Math.random() < 0.001) {
                            const samples = Math.floor(audioData.length / 2);
                            console.log(`Received WS audio data: ${audioData.length} bytes, queue: ${this.pcmDataQueue.length} packets`);
                        }
                        
                        // MODIFIED: Always process audio regardless of visibility
                        if (this.audioWorkletNode && this.audioWorkletNode.port) {
                            if (this.audioContext && this.audioContext.state === 'running') {
                                try {
                                    this.audioWorkletNode.port.postMessage({
                                        type: 'buffer',
                                        buffer: audioData
                                    });
                                } catch (err) {
                                    console.error('Error sending data to AudioWorklet:', err);
                                    this.pcmDataQueue.push(audioData);
                                }
                            } else {
                                this.pcmDataQueue.push(audioData);
                            }
                        } else {
                            this.pcmDataQueue.push(audioData);
                            
                            // Use different buffer sizes based on visibility
                            const maxQueueSize = document.hidden ? 30 : 12;
                            const minQueueSize = document.hidden ? 10 : 3;
                            
                            if (this.pcmDataQueue.length > maxQueueSize) {
                                if (this.pcmDataQueue.length > maxQueueSize + 3) {
                                    const toRemove = Math.min(3, this.pcmDataQueue.length - maxQueueSize);
                                    this.pcmDataQueue.splice(1, toRemove);
                                    if (Math.random() < 0.1) {
                                        console.warn(`Severe overflow: removed ${toRemove} packets`);
                                    }
                                } else {
                                    const middleIndex = Math.floor(this.pcmDataQueue.length / 2);
                                    this.pcmDataQueue.splice(middleIndex, 1);
                                }
                            }
                        }
                    }
                };
                
                // Handle errors
                this.webSocket.onerror = (error) => {
                    // Keep error logs
                    console.error('WebSocket error:', error);
                    
                    // If using auto transport mode, try falling back to SSE on error
                    if (this.streamTransport === 'auto' && this.isPlaying) {
                        if (this.webSocket) {
                            this.webSocket.close();
                            this.webSocket = null;
                        }
                        this.setupSSEForSource(sourceId);
                    }
                };
                
                // Handle connection close
                this.webSocket.onclose = (event) => {
                    // Only log abnormal closures
                    if (event.code !== 1000) {
                        console.log(`WebSocket connection closed with code ${event.code}`);
                    }
                    
                    // Only attempt to reconnect if we're still playing and it wasn't a normal closure
                    if (this.isPlaying && event.code !== 1000) {
                        setTimeout(() => {
                            if (this.isPlaying) {
                                // If using auto transport mode, try SSE after WebSocket failure
                                if (this.streamTransport === 'auto') {
                                    this.setupSSEForSource(sourceId);
                                } else {
                                    this.setupWebSocketConnection(sourceId);
                                }
                            }
                        }, 1000);
                    }
                };
                
                // Keep connection alive with periodic pings
                this.pingInterval = setInterval(() => {
                    if (this.webSocket && this.webSocket.readyState === WebSocket.OPEN) {
                        // Send a small ping message
                        this.webSocket.send('ping');
                    }
                }, 20000);
                
            } catch (error) {
                // Keep error logs
                console.error('Error setting up WebSocket:', error);
                
                // Try SSE as fallback
                if (this.streamTransport === 'auto') {
                    this.setupSSEForSource(sourceId);
                }
            }
        },

        togglePlayback() {
            if (!this.selectedSource) {
                console.error('No audio source selected');
                return;
            }
            
            // Toggle playback state
            this.isPlaying = !this.isPlaying;
            
            if (this.isPlaying) {
                // Keep this log to indicate user action
                console.log('Starting audio playback...');
                
                // Initialize audio system if needed
                if (!this.audioContext) {
                    this.initAudio();
                } else if (this.audioContext.state === 'closed') {
                    this.audioContext = null;
                    this.audioWorkletNode = null;
                    this.initAudio();
                }
                
                // Always resume audio context regardless of visibility
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume().catch(err => {
                        console.error('Failed to resume audio context:', err);
                    });
                }
                
                // Reset processing state
                this.processingStarted = false;
                this.pcmDataQueue = [];
                this.sseStalled = false;
                this.sseStallRecoveryAttempts = 0;
                
                // Set up streaming connection
                this.setupWebSocketForSource(this.selectedSource);
                
                // ADD MediaSession API support
                if ('mediaSession' in navigator) {
                    navigator.mediaSession.metadata = new MediaMetadata({
                        title: 'Bird Audio Stream',
                        artist: 'BirdNet-Go',
                        album: 'Live Stream',
                        // Optional artwork - use favicon as default
                        artwork: [
                            { src: '/assets/favicon.ico', sizes: '32x32', type: 'image/x-icon' },
                        ]
                    });
                    
                    navigator.mediaSession.setActionHandler('play', () => {
                        this.isPlaying = true;
                        this.setupWebSocketForSource(this.selectedSource);
                    });
                    
                    navigator.mediaSession.setActionHandler('pause', () => {
                        this.isPlaying = false;
                        this.cleanupAudioResources();
                    });
                    
                    // Update playback state
                    navigator.mediaSession.playbackState = 'playing';
                }
                
            } else {
                // Keep this log to indicate user action
                console.log('Stopping audio playback...');
                
                // Clean up all resources
                this.cleanupAudioResources();
                
                // Update mediaSession state if available
                if ('mediaSession' in navigator) {
                    navigator.mediaSession.playbackState = 'paused';
                }
                
                // Only suspend audio context if navigating away
                if (this.isNavigating && this.audioContext && this.audioContext.state === 'running') {
                    this.audioContext.suspend().catch(err => {
                        console.error('Failed to suspend audio context:', err);
                    });
                }
            }
        },

        init() {
            // Setup initial connection
            this.setupEventSource();
            
            // Listen for navigation events
            document.addEventListener('htmx:beforeRequest', () => {
                this.isNavigating = true;
                this.cleanupEventSource();
                
                // Clean up audio resources
                if (this.pingInterval) {
                    clearInterval(this.pingInterval);
                    this.pingInterval = null;
                }
                
                // Close all connections
                this.closeExistingConnections();
                
                if (this.audioContext) {
                    this.audioContext.suspend().catch(err => {
                        console.error('Failed to suspend audio context:', err);
                    });
                }
            });
            
            document.addEventListener('htmx:afterRequest', () => {
                this.isNavigating = false;
                // Only setup new connection if we're still on a page that needs it
                if (document.body.contains(this.$el)) {
                    this.setupEventSource();
                }
            });

            // Listen for page visibility changes
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    // When tab goes to background
                    this.cleanupEventSource(); // Still close the audio level EventSource
                    
                    // REMOVED: Don't suspend audio context in background
                    if (this.isPlaying) {
                        // Adjust buffer size when in background to reduce CPU usage but keep audio flowing
                        this.bufferThreshold = Math.max(3, this.bufferThreshold);
                        console.log('Tab in background: continuing audio playback with adjusted buffering');
                        
                        // Make sure audio context is running
                        if (this.audioContext && this.audioContext.state === 'suspended') {
                            this.audioContext.resume().catch(err => {
                                console.error('Failed to resume audio context in background:', err);
                            });
                        }
                    }
                    
                } else if (!this.isNavigating) {
                    // When tab becomes visible again
                    this.setupEventSource();
                    
                    // Resume streaming if needed when page becomes visible again
                    if (this.isPlaying && this.selectedSource) {
                        // Keep this log but make it less frequent by checking if actually playing
                        console.log('Tab visible again: resuming audio playback');
                        
                        // Always try to resume the audio context when tab becomes visible
                        if (this.audioContext) {
                            this.audioContext.resume().catch(err => {
                                console.error('Failed to resume audio context:', err);
                            });
                        }
                        
                        // Reestablish connection only if needed
                        if (this.streamTransport === 'sse' || (this.streamTransport === 'auto' && this.isCloudflareOrDocker())) {
                            if (!this.sseSource) {
                                this.setupSSEForSource(this.selectedSource);
                            }
                        } else if (!this.webSocket || this.webSocket.readyState !== WebSocket.OPEN) {
                            this.setupWebSocketConnection(this.selectedSource);
                        }
                    }
                }
            });
            
            // Clean up on component destroy
            this.$cleanup = () => {
                this.cleanupEventSource();
                document.removeEventListener('visibilitychange', this.cleanupEventSource);
                document.removeEventListener('htmx:beforeRequest', this.cleanupEventSource);
                document.removeEventListener('htmx:afterRequest', this.setupEventSource);
                
                // Clean up audio resources
                if (this.webSocket) {
                    this.webSocket.close();
                }
                
                if (this.audioContext) {
                    this.audioContext.close();
                }
            };
        },
        getCurrentLevel() {
            const level = this.selectedSource && this.levels[this.selectedSource] ? 
                this.levels[this.selectedSource].level : 0;
            return level;
        },
        isClipping() {
            const clipping = this.selectedSource && this.levels[this.selectedSource] ? 
                this.levels[this.selectedSource].clipping : false;
            return clipping;
        },
        getSmoothedVolume() {
            const volume = this.selectedSource ? this.smoothedVolumes[this.selectedSource] || 0 : 0;
            return volume;
        },
        getSourceDisplayName(source) {
            const name = this.levels[source]?.name || source;
            return name;
        },
        // Modify the cleanup resources method
        cleanupAudioResources() {
            // MODIFY: Only clean up completely if not playing or if navigating away
            if (!this.isPlaying || this.isNavigating) {
                // Clear all intervals
                if (this.bufferStatsInterval) {
                    clearInterval(this.bufferStatsInterval);
                    this.bufferStatsInterval = null;
                }
                
                if (this.sseStallCheckInterval) {
                    clearInterval(this.sseStallCheckInterval);
                    this.sseStallCheckInterval = null;
                }
                
                if (this.pingInterval) {
                    clearInterval(this.pingInterval);
                    this.pingInterval = null;
                }
                
                // Close connections
                this.closeExistingConnections();
                
                // Clear the data queue
                this.pcmDataQueue = [];
                
                // Reset state
                this.processingStarted = false;
                this.bufferUnderrunCount = 0;
                this.sseStalled = false;
                this.sseStallRecoveryAttempts = 0;
            } else {
                // Lighter cleanup that preserves audio playback
                // Don't close connections or reset state that would interrupt playback
                console.log('Light cleanup to preserve background audio playback');
            }
        }
    }" 
    @click.away="dropdownOpen = false">
    
    <!-- Audio level indicator circle -->
    <button @click="dropdownOpen = !dropdownOpen" 
            class="w-full h-full relative focus:outline-none group" 
            :aria-expanded="dropdownOpen"
            aria-haspopup="true"
            :aria-label="'Audio level for ' + (selectedSource ? getSourceDisplayName(selectedSource) : 'No source')"
            tabindex="0">
        <svg class="w-full h-full" viewBox="0 0 36 36" aria-hidden="true">
            <!-- Background circle path -->
            <path d="M18 2.0845
                        a 15.9155 15.9155 0 0 1 0 31.831
                        a 15.9155 15.9155 0 0 1 0 -31.831" 
                    fill="none" 
                    stroke="#E5E7EB" 
                    stroke-width="3" 
                    stroke-dasharray="100, 100"></path>
            <!-- Foreground circle path -->
            <path d="M18 33.9155
                        a 15.9155 15.9155 0 0 1 0 -31.831
                        a 15.9155 15.9155 0 0 1 0 31.831" 
                    fill="none" 
                    :stroke="isClipping() ? '#EF4444' : '#10B981'" 
                    stroke-width="3" 
                    :stroke-dasharray="`${getSmoothedVolume()}, 100`"
                    stroke-linecap="round">
            </path>
        </svg>
        <div class="absolute inset-0 flex items-center justify-center">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                <path fill-rule="evenodd" d="M7 4a3 3 0 016 0v4a3 3 0 11-6 0V4zm4 10.93A7.001 7.001 0 0017 8a1 1 0 10-2 0A5 5 0 015 8a1 1 0 00-2 0 7.001 7.001 0 006 6.93V17H6a1 1 0 100 2h8a1 1 0 100-2h-3v-2.07z" clip-rule="evenodd"></path>
            </svg>
        </div>
        <!-- Live region to announce volume changes -->
        <div class="sr-only" aria-live="polite" x-text="'Current audio level: ' + Math.round(getSmoothedVolume()) + ' percent' + (isClipping() ? ', clipping detected' : '')"></div>
    </button>

    {{if or (not $.Security.Enabled) $.Security.AccessAllowed}}
    <!-- Tooltip for selected source -->
    <div x-show="selectedSource && !dropdownOpen"
         x-transition:enter="transition ease-out duration-100"
         x-transition:enter-start="opacity-0"
         x-transition:enter-end="opacity-100"
         x-transition:leave="transition ease-in duration-75"
         x-transition:leave-start="opacity-100"
         x-transition:leave-end="opacity-0"
         class="invisible group-hover:visible absolute left-1/2 transform -translate-x-1/2 -translate-y-full mt-2 px-2 py-1 bg-gray-900 text-gray-50 text-sm rounded whitespace-nowrap z-50"
         style="top: -5px;"
         aria-hidden="true">
        <span x-text="selectedSource ? getSourceDisplayName(selectedSource) : 'No source selected'"></span>
    </div>
    
    <!-- Dropdown menu, shown only for authenticated users -->
    <div x-show="dropdownOpen"
         role="dialog"
         aria-modal="true"
         :aria-label="'Audio Source Selection'"
         class="absolute p-1 right-0 mt-2 w-auto min-w-[12rem] max-w-[90vw] overflow-hidden rounded-md shadow-lg bg-base-100 ring-1 ring-black ring-opacity-5 z-50"
         x-transition:enter="transition ease-out duration-100"
         x-transition:enter-start="opacity-0 scale-95"
         x-transition:enter-end="opacity-100 scale-100"
         x-transition:leave="transition ease-in duration-75"
         x-transition:leave-start="opacity-100 scale-100"
         x-transition:leave-end="opacity-0 scale-95"
         @keydown.escape.window="dropdownOpen = false"
         @keydown.tab="$event.shiftKey || $el.querySelector('.last-focusable').focus()"
         @keydown.shift.tab="$el.querySelector('.first-focusable').focus()">
        <div class="py-1" role="menu" aria-orientation="vertical">
            <template x-if="Object.keys(levels).length === 0">
                <div class="px-4 py-2 text-sm text-base-content/60" role="menuitem">No audio sources available</div>
            </template>
            <template x-for="(data, source) in levels" :key="source">
                <div class="flex flex-row items-center w-full p-2 text-sm hover:bg-base-200 rounded-md"
                     :class="{
                         'bg-base-200': selectedSource === source,
                         'text-base-content/50': isInactive(source),
                         'text-base-content': !isInactive(source)
                     }"
                     role="menuitem"
                     :id="'source-item-' + source">
                    <!-- Source name area (clickable to select) -->
                    <button @click="selectedSource = source; dropdownOpen = false" 
                            class="flex-1 text-left flex items-center justify-between"
                            role="menuitemradio"
                            :aria-checked="selectedSource === source"
                            :tabindex="source === Object.keys(levels)[0] ? 0 : -1"
                            :class="{ 'first-focusable': source === Object.keys(levels)[0] }"
                            @keydown.right="$event.target.nextElementSibling?.focus()">
                        <span class="flex-1 whitespace-nowrap" x-text="getSourceDisplayName(source)"></span>
                        <span x-show="isInactive(source)" class="text-xs text-base-content/50 shrink-0 ml-2" aria-hidden="true">(silent)</span>
                        <!-- Accessible label that includes silence status -->
                        <span class="sr-only" x-text="isInactive(source) ? getSourceDisplayName(source) + ' (currently silent)' : getSourceDisplayName(source)"></span>
                    </button>
                    
                    <!-- Play/Stop controls directly in same row -->
                    <button x-show="selectedSource === source"
                            @click="togglePlayback(); dropdownOpen = false" 
                            class="btn btn-xs btn-circle btn-ghost ml-2"
                            :class="isPlaying ? 'text-error' : 'text-success'"
                            :aria-label="isPlaying ? 'Stop audio playback' : 'Start audio playback'"
                            :tabindex="selectedSource === source ? 0 : -1"
                            :class="{ 'last-focusable': selectedSource === source }"
                            @keydown.left="$event.target.previousElementSibling?.focus()">
                        <template x-if="!isPlaying">
                            <!-- Play icon (>) -->
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
                            </svg>
                        </template>
                        <template x-if="isPlaying">
                            <!-- Stop icon (#) -->
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 001 1h4a1 1 0 001-1V8a1 1 0 00-1-1H8z" clip-rule="evenodd" />
                            </svg>
                        </template>
                    </button>
                </div>
            </template>
        </div>
    </div>
    
    {{end}}

    <!-- Live region for audio playback status -->
    <div aria-live="polite" class="sr-only">
        <span x-show="isPlaying" x-text="'Now playing audio from ' + (selectedSource ? getSourceDisplayName(selectedSource) : 'unknown source')"></span>
        <span x-show="!isPlaying && selectedSource" x-text="'Audio playback stopped'"></span>
    </div>

</div>

<!-- Add this script to the bottom for better keyboard navigation -->
<script>
document.addEventListener('alpine:init', () => {
    // A11y: Enhance keyboard interaction for dropdown
    window.addEventListener('keydown', (e) => {
        // Close dropdown on escape
        if (e.key === 'Escape' && Alpine.$data(document.querySelector('[x-data*="dropdownOpen"]')).dropdownOpen) {
            Alpine.$data(document.querySelector('[x-data*="dropdownOpen"]')).dropdownOpen = false;
        }
    });
});
</script>
{{end}} 