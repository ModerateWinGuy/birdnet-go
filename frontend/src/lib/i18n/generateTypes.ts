/// <reference types="node" />
/**
 * Script to generate TypeScript types from the English translation file
 * This ensures compile-time validation of translation keys
 */

import { readFileSync, writeFileSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

type TranslationValue = string | Record<string, unknown>;
type TranslationObject = Record<string, TranslationValue>;

/**
 * Recursively generates TypeScript type definitions from a translation object
 */
function generateTypeFromObject(obj: TranslationObject, prefix = ''): string {
  const lines: string[] = [];

  for (const [key, value] of Object.entries(obj)) {
    const fullKey = prefix ? `${prefix}.${key}` : key;

    if (typeof value === 'string') {
      // Extract parameters from the translation string
      const params = extractParameters(value);
      if (params.length > 0) {
        lines.push(`  | '${fullKey}' // params: ${params.join(', ')}`);
      } else {
        lines.push(`  | '${fullKey}'`);
      }
    } else if (typeof value === 'object') {
      // Recursively process nested objects
      const nestedTypes = generateTypeFromObject(value as TranslationObject, fullKey);
      const nestedLines = nestedTypes.split('\n');
      const filteredLines = nestedLines.filter(l => l.trim());
      lines.push(...filteredLines);
    }
  }

  return lines.join('\n');
}

/**
 * Extracts parameter names from a translation string
 * e.g., "Hello {name}, you have {count} messages" -> ['name', 'count']
 */
function extractParameters(str: string): string[] {
  const regex = /\{(\w+)\}/g;
  const params: string[] = [];
  let match;
  let lastIndex = -1;

  while ((match = regex.exec(str)) !== null) {
    // Safety check: ensure lastIndex advances to prevent infinite loop
    if (regex.lastIndex <= lastIndex) {
      break;
    }
    lastIndex = regex.lastIndex;

    if (!params.includes(match[1])) {
      params.push(match[1]);
    }
  }

  return params;
}

/**
 * Generates parameter type definitions for translations with parameters
 */
function generateParamTypes(obj: TranslationObject, prefix = ''): string[] {
  const paramTypes: string[] = [];

  for (const [key, value] of Object.entries(obj)) {
    const fullKey = prefix ? `${prefix}.${key}` : key;

    if (typeof value === 'string') {
      const params = extractParameters(value);
      if (params.length > 0) {
        const paramType = params.map(p => `${p}: string | number`).join('; ');
        paramTypes.push(`  '${fullKey}': { ${paramType} };`);
      }
    } else if (typeof value === 'object') {
      paramTypes.push(...generateParamTypes(value as TranslationObject, fullKey));
    }
  }

  return paramTypes;
}

/**
 * Main function to generate types from the English translation file
 * Reads the en.json file and creates a TypeScript file with:
 * - Union type of all available translation keys
 * - Parameter types for translations that require interpolation
 * - Type-safe translation function signature
 */
function generateTypes() {
  try {
    // Read the English translation file
    const messagesPath = join(__dirname, '../../../static/messages/en.json');
    const enMessages = JSON.parse(readFileSync(messagesPath, 'utf-8'));

    // Generate translation key type
    const translationKeys = generateTypeFromObject(enMessages);

    // Generate parameter types
    const paramTypes = generateParamTypes(enMessages);

    // Create the TypeScript content
    const tsContent = `/**
 * Auto-generated TypeScript types for i18n translation keys
 * Generated from: static/messages/en.json
 * 
 * DO NOT EDIT THIS FILE MANUALLY
 * Run 'npm run generate:i18n-types' to regenerate
 */

/**
 * All available translation keys
 */
export type TranslationKey =
${translationKeys};

/**
 * Parameter types for translations that require parameters
 */
export type TranslationParams = {
${paramTypes.join('\n')}
};

/**
 * Helper type to get parameters for a specific translation key
 */
export type GetParams<K extends TranslationKey> = K extends keyof TranslationParams
  ? TranslationParams[K]
  : never;

/**
 * Type-safe translation function signature
 */
export interface TranslateFunction {
  <K extends TranslationKey>(
    key: K,
    ...args: GetParams<K> extends never ? [] : [GetParams<K>]
  ): string;
}
`;

    // Write the TypeScript file
    const outputPath = join(__dirname, 'types.generated.ts');
    writeFileSync(outputPath, tsContent, 'utf-8');

    console.log(`‚úÖ Generated TypeScript types at: ${outputPath}`);
    console.log(`üìä Total translation keys: ${translationKeys.split('\n').length - 1}`);
    console.log(`üìä Keys with parameters: ${paramTypes.length}`);
  } catch (error) {
    console.error('‚ùå Error generating types:', error);
    process.exit(1);
  }
}

// Run the generator
generateTypes();
